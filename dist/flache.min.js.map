{"version":3,"file":"flache.min.js","mappings":"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","sources":["webpack://flachejs/webpack/universalModuleDefinition","webpack://flachejs/external umd {\"commonjs\":\"localforage\",\"commonjs2\":\"localforage\",\"amd\":\"localforage\",\"root\":\"localforage\"}","webpack://flachejs/external umd {\"commonjs\":\"md5\",\"commonjs2\":\"md5\",\"amd\":\"md5\",\"root\":\"md5\"}","webpack://flachejs/webpack/bootstrap","webpack://flachejs/webpack/runtime/compat get default export","webpack://flachejs/webpack/runtime/define property getters","webpack://flachejs/webpack/runtime/hasOwnProperty shorthand","webpack://flachejs/webpack/runtime/make namespace object","webpack://flachejs/./src/helpers/synthResponse.js","webpack://flachejs/./src/helpers/flacheRequest.js","webpack://flachejs/./src/helpers/copyResponse.js","webpack://flachejs/./src/helpers/parsers.js","webpack://flachejs/./src/flacheStorage.js","webpack://flachejs/./src/flache.js","webpack://flachejs/./src/helpers/generateKey.js","webpack://flachejs/./src/helpers/validateCache.js","webpack://flachejs/./src/helpers/serverRequest.js","webpack://flachejs/./src/helpers/reqExtension.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"md5\"), require(\"localforage\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"md5\", \"localforage\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flachejs\"] = factory(require(\"md5\"), require(\"localforage\"));\n\telse\n\t\troot[\"flachejs\"] = factory(root[\"md5\"], root[\"localforage\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__99__, __WEBPACK_EXTERNAL_MODULE__428__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__428__;","module.exports = __WEBPACK_EXTERNAL_MODULE__99__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export class SyntheticResponse extends Response {\n  #redirected;\n  #type;\n  #url;\n  constructor(body, init) {\n    super(body, init);\n    this.#redirected = init.redirected || false;\n    this.#url = init.url || '';\n    this.#type = init.type || 'default';\n  }\n\n  get url() {\n    return this.#url;\n  }\n\n  get redirected() {\n    return this.#redirected;\n  }\n\n  get type() {\n    return this.#type;\n  }\n}\n\nexport function constructResponse(entry) {\n  const init = {\n    ...entry.response,\n    headers: new Headers(entry.response.headers),\n  }\n  /**\n   * The only properties that acan actually be set via our options are as follow: \n   * Status\n   * Status Text\n   * Headers\n   * \n   * Our 'synthetic reposne' overwirtes the getter functions for the url, redirect, and the type to mimic\n   * the native api as much as possible. Unclear if this could cause serious bugs or not yet. \n   * \n   * We should consider what if any of the other properties may interfere with the normal workflow\n   * a developer might expect, and also how this will impact any other native functions\n   * that interface with the response obj. \n   * \n   * For example - if a user is redirected, but the header is set to manual, the response will not\n   * be automatically redirected and the user will have to specify a control flow to handle this. \n   *\n   * Additionally - in testing I've noticed that the clone method does not work properly either. \n   */\n\n\n  // TO-DO Make sure to parse the data appropriately if it is text v. JSON \n  const outputResponse = new SyntheticResponse(JSON.stringify(entry.data.data), init)\n \n  return outputResponse;\n}\n\n","import { constructResponse } from './synthResponse';\n\n/**\n * Function to retreive data from Cache\n * @param {string} url - the url to the server request\n * @param {object} options - the request body\n * @return {object} Object containing the retreived data from the cache\n */\n\n const defaultOptions = {\n  method: 'GET',\n  mode: 'cors',\n  cache: 'default',\n  credentials: 'same-origin',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  redirect: 'follow',\n  referrerPolicy: 'no-referrer-when-downgrade',\n  body: null,\n}\n\n// TO-DO Add errror handling and potentially some routing. \nconst flacheRequest = async function (url, options) {\n  \n  let start = performance.now()\n\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n\n  let uniqueKey = this.generateKey(url, options);\n\n  /** Check if the cache already contains the response to the given url or exists in cache but is invalid */\n  const cacheResult = await this.store.getItem(uniqueKey)\n    .then((entry) => {\n      if (!entry) return null;\n      // needs to return data if valid and null if not;\n      return this.validateCache(uniqueKey, entry);\n    })\n    .catch(err => err);\n\n  // what should we do if this throws an err? -> err would indicate that storage is full for write operations \n  // read operations this would probably indicate an issue with the store itself. \n\n  /** If the cache does not already have stored response from the given url */\n  if (!cacheResult) {\n    /** Make a request to the server through the url param to store its response */\n    const apiResult = await this.getFetchRequest(url, options);\n\n    // if no data returned - should we try again or return an error? \n    if (!apiResult) {\n      return null;\n    }\n\n    /** Apply TTL to object to be stored in cache */\n    apiResult.ttl = Date.now() + this.ttl;\n    /** Add to cache */\n    await this.store.setItem(uniqueKey, apiResult);\n    // this is where we would potetnially trigger evictions\n    this.duration = (performance.now() - start).toFixed(2);\n    this.reqExtension(url, this.duration, 'Miss', this.ttl);\n    return constructResponse(apiResult);\n  }\n  \n  this.duration = (performance.now() - start).toFixed(2);\n  this.reqExtension(url, this.duration, 'Hit', -1);\n  return constructResponse(cacheResult);\n};\n\n\nexport default flacheRequest;\n","function copyResponse(res, skip = ['body']) {\n  if (!(res instanceof Response)) throw new Error('Not a valid response object'); \n\n  const newObj = {};\n  for (const key in res) {\n    // this is to avoid copying function definitions from the objects prototype; \n    // it also checks if we have marked this as a property ot skip. \n    if (skip.includes(key) || typeof res[key] === 'function') continue;\n   \n    //This is to iterate through the headers obj and copy all of the headers returned by the server\n    // we will reconstruct this later and recreate the exact same response. \n    if (key === 'headers') {\n      newObj[key] = copyHeaders(res[key]);\n      continue; \n    }\n    newObj[key] = res[key]; \n  }\n  return newObj; \n}\n\nfunction copyHeaders(header) {\n  const entries = header.entries();\n\n  const newObj = {};\n\n  for (const [key, value] of entries) {\n    newObj[key] = value;\n  }\n\n  return newObj\n}\n\nexport default copyResponse","import copyResponse from './copyResponse';\n\n/**\n * Parse response from the server to record the data type\n * Middleware pattern calls functions in order until it receives valid data from response\n * @param {Response} res - response from server request\n * @param {string} res - response from server request\n * @return {object} Object containing the resulting data from executing the request in the server and the response detils for later reconstruction. \n */\n\n\nasync function parseResponse(res) {\n  const responseCopy = copyResponse(res);\n  const dataCopy = await parseJSON(res); \n\n  if (!dataCopy) throw new Error('failed to parse data');\n\n  return { response: responseCopy, data: dataCopy };\n}\n\n\nasync function parseJSON(res) {\n  try {\n    const data = { type: 'json', data: await res.json() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseText(res);\n  }\n}\n\n\nasync function parseText(res) {\n  try {\n    const data = { type: 'text', data: await res.text() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseBlob(res);\n  }\n}\n\n// Note these are still in experimental phase\nasync function parseBlob(res) {\n  try {\n    const data = { type: 'blob', data: await res.blob() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseArrayBuffer(res);\n  }\n}\n\nasync function parseArrayBuffer(res) {\n  try {\n    const data = { type: 'buffer', data: await res.arrayBuffer() };\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return null;\n  }\n}\n\nexport default parseResponse","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.value = val;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\n// Implement the driver here.\nconst flacheStorage = {\n  _driver: 'FLACHESTORAGE',\n  _initStorage: function(capacity, options) {\n    this.capacity = capacity;\n    this.cache = new Map(); \n    this.head = null;\n    this.tail = null;\n\n    if (options) {\n      for (let key in options) {\n        this.cache[key] = options[key];\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  clear: function (callback) {\n\n    return new Promise((resolve, reject) => { \n      try {\n        this.cache.clear(); \n        resolve(true);\n      } catch (err) {\n        reject(err)\n      }\n    })\n  },\n  \n  getItem: function(key) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.cache.has(key)) {\n          let node = this.cache.get(key);\n          this.moveToFront(node);\n          return resolve(node.value);\n        }\n        \n        return resolve(null);\n      } catch (err) {\n        reject(err); \n      }\n    })\n  },\n\n  iterate: function(iteratorCallback, successCallback) {\n      // Custom implementation here...\n      // TO-DO \n  },  \n\n  key: function (n, callback) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (n < 0 || !this.head) return resolve(null);\n    \n        if (n === 0) {\n          if (!callback) resolve(this.head.key);\n          resolve(callback(this.head.key));\n        } \n        \n        let start = this.head; \n        let count = 0;\n    \n        while (start) {\n          start = start.next;\n          count++;\n          if (count === n) break;\n        }\n    \n        if (count < n) resolve(null);\n    \n        if(!callback) resolve(start.key);\n        resolve(callback(start.key));\n      } catch (err) {\n        reject(err);\n      }\n  })\n  },\n\n  keys: function (callback) {\n    return new Promise((resolve, reject) => {\n      try {\n        const keys = this.cache.keys();\n        if (!callback) resolve([...keys])\n        resolve(callback([...keys]));\n      } catch (err) {\n        reject(err)\n      }\n    })\n  },\n\n  length: function (callback) {\n    return this.keys().then(keys => {\n      const length = keys.length;\n      if (!callback) return length;\n      return callback(length);\n    });\n  },\n\n  removeItem: function(key, callback) {\n    delete this.cache[key];\n    return Promise.resolve();\n  },\n\n  setItem: function(key, value) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.cache.has(key)) {\n          let node = this.cache.get(key);\n          node.value = value;\n          this.moveToFront(node);\n          resolve(value);\n        }\n        \n        let node = new Node(key, value);\n    \n        if (this.cache.size === this.capacity) {\n          this.cache.delete(this.tail.key);\n          this.deleteNode(this.tail);\n        }\n    \n        this.cache.set(key, node);\n        this.addFirst(node);\n        resolve(value);\n\n      } catch (err) {\n        reject(err);\n      }\n    })\n  },\n\n  moveToFront: function(node) {\n    this.deleteNode(node);\n    this.addFirst(node);\n    return;\n  },\n\n  deleteNode: function(node) {\n    let prevNode = node.prev;\n    let nextNode = node.next;\n\n    if (prevNode) {\n      prevNode.next = nextNode;\n    } else {\n      this.head = nextNode;\n    }\n\n    if (nextNode) {\n      nextNode.prev = prevNode;\n    } else {\n      this.tail = prevNode;\n    }\n\n    return;\n  },\n\n  addFirst: function(node) {\n    node.next = this.head;\n    node.prev = null;\n\n    if (this.head) {\n      this.head.prev = node;\n    }\n\n    this.head = node;\n\n    if (!this.tail) {\n      this.tail = node;\n    }\n\n    return;\n  },\n \n  printLL: function () {\n    console.log('This is our Linked List \\n', this.head)\n  }\n}\n\n\nexport default flacheStorage;","import flacheRequest from './helpers/flacheRequest';\nimport generateKey from './helpers/generateKey';\nimport validateCache from './helpers/validateCache';\nimport getFetchRequest from './helpers/serverRequest';\nimport reqExtension from './helpers/reqExtension';\n\n/**\n * The localforage module\n * @external \"localforage\"\n * @see {@link https://www.npmjs.com/package/localforage}\n */\n\nimport localforage from 'localforage';\n\nimport FLACHESTORAGE from './flacheStorage';\n\nlocalforage.defineDriver(FLACHESTORAGE);\n\n// import testStorage from './flacheStorageTest';\n\nconst defaultOptions = {\n  maxCapacity: null, // this is only relevant for local memory at the moment. \n  ttl: 5000,\n  duration: null,\n  config: {\n    name: 'httpCache',\n    storeName: 'request_response',\n    description: 'A cache for client-side http requests',\n    driver: [\n      FLACHESTORAGE._driver,\n      localforage.INDEXEDDB,\n      localforage.LOCALSTORAGE,\n    ],\n    version: 1.0, // this is only relevant if using IndexedDB\n  }\n}\n\n/** class clientCache provides a container for our db store */\nclass clientCache {\n\n  /**\n   * create a clientCache\n   * @param {object} options - further options for configuring the store\n   */\n  \n  constructor(options = defaultOptions) {\n\n    /** Create store and override the default store options with user-given configurations */\n    // TO-DO: check if the store exists already and create new store only if it isn't already there.\n    this.store = localforage.createInstance(({\n      ...defaultOptions.config,\n      ...options.config\n    }))\n\n    /** Create details store */\n    // TO-DO: same as above. \n    this.details = localforage.createInstance({\n      name: 'cacheDetails',\n      storeName: 'requests',\n      description: 'A list of past requests',\n      driver: localforage.INDEXEDDB,\n      version: 1.0,\n    })\n\n    /** Apply TTL (time to live) and maxCapacity from user configuration or default */\n    this.ttl = options.ttl || defaultOptions.ttl;\n    this.maxCapacity = options.maxCapacity;\n    this.duration = defaultOptions.duration;\n  }\n\n  static INDEXEDDB = localforage.INDEXEDDB;\n  static LOCALSTORAGE = localforage.LOCALSTORAGE;\n  static MEMORY = 'FLACHESTORAGE';\n}\n\n/** bind helper functions to class clientCache */\nclientCache.prototype.flacheRequest = flacheRequest;\nclientCache.prototype.generateKey = generateKey;\nclientCache.prototype.validateCache = validateCache;\nclientCache.prototype.getFetchRequest = getFetchRequest;\nclientCache.prototype.reqExtension = reqExtension;\n\nexport default clientCache","import md5 from 'md5';\n  \n/**\n* Function that takes in arguments of an HTTP request and returns them as a single unique (hashed) key\n* @param {string} url - request URL\n* @param {object} data - object containing request body such as the HTTP method\n* @return {string} - Hashed key\n**/\n// TO-DO consider including headers in our hashing strategy? If a POST request is made with different headers its conceivable that\n// the expected repsonse would be different;       \nconst generateKey = (url, data) => {\n  // TO-DO error handling for incorrect method\n  const method = data.method.toUpperCase();\n  if (method === 'GET') {\n    return (`${method}/${url}`);\n  }\n  if (method === 'POST') {\n    if (!Object.hasOwn(data, 'body')) throw new Error('Must include a body with POST request');\n    return (`${method}/${md5(JSON.stringify(data.body))}/${url}`);\n  }\n}\n\nexport default generateKey;","/**\n * Function that validates the cache\n * @param {string} uniqueKey - hashed key that contains request url and body\n * @param {object} data - response from the server request containing the request's TTL\n * @return {object} object cache value (keys: ttl, data) if in cache and valid, null if not\n */\nasync function validateCache(uniqueKey, data) {\n  // check if the item in the store's TTL has passed from the current time of the function call\n  if (data.ttl < Date.now()) {\n    await this.store.removeItem(uniqueKey);\n    return null;\n  } else return data;\n}\n\nexport default validateCache;","import parseResponse from './parsers'; \n\n/**\n * Function that makes a Fetch request to the server\n * @param {string} url URL to where fetch request is being made\n * @return {object} Object containing the resulting data from executing the request in the server\n */\n\n/**\n * How will we handle being redirected? \n */\n\nasync function getFetchRequest(url, options) {\n  // TO-DO handling headers, response-types, etc for how to parse data; \n  let response = await fetch(url, options)\n    .then(res => {\n      const proxyResponse = parseResponse(res);\n      return proxyResponse;\n    })\n    .catch(err => {\n      console.log('Fetch error', err.message);\n      return err;\n    });\n  return response;\n}\n\nexport default getFetchRequest;","const reqExtension = (url, duration, inCache, TTL) => {\n    // Send data to our Extension\n    if(chrome && chrome.runtime && chrome.runtime.sendMessage) {\n        async function sendReq () {\n          let aRequest = {\n            requestURL: url,\n            time: duration, \n            inCache: inCache,\n            ttl: TTL\n          }\n          chrome.runtime.sendMessage(\"bmkhjogdgeafjdanmhjddmcldejpgaga\", aRequest);\n        }  \n        sendReq();\n    }\n}\n  \nexport default reqExtension;"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__99__","__WEBPACK_EXTERNAL_MODULE__428__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","SyntheticResponse","Response","constructor","body","init","super","this","redirected","url","type","constructResponse","entry","response","headers","Headers","JSON","stringify","data","defaultOptions","method","mode","cache","credentials","redirect","referrerPolicy","copyHeaders","header","entries","newObj","async","res","responseCopy","skip","Error","includes","dataCopy","json","err","console","log","message","text","blob","arrayBuffer","parseArrayBuffer","parseBlob","parseText","parseJSON","Node","val","next","prev","_driver","_initStorage","capacity","options","Map","head","tail","Promise","resolve","clear","callback","reject","getItem","has","node","moveToFront","iterate","iteratorCallback","successCallback","start","count","keys","length","then","removeItem","setItem","size","delete","deleteNode","set","addFirst","prevNode","nextNode","printLL","maxCapacity","ttl","duration","config","name","storeName","description","driver","version","clientCache","store","details","static","flacheRequest","performance","now","uniqueKey","generateKey","cacheResult","validateCache","catch","apiResult","getFetchRequest","Date","toFixed","reqExtension","toUpperCase","hasOwn","fetch","inCache","TTL","chrome","runtime","sendMessage","sendReq","aRequest","requestURL","time"],"sourceRoot":""}