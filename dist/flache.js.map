{"version":3,"file":"flache.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;ACVA;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;ACrDoD;;AAEpD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;;;AAGA,4DAAe,aAAa,EAAC;;;;;;ACxEP;AACtB;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,GAAG,IAAI;AAC7B;AACA;AACA;AACA,eAAe,OAAO,GAAG,8DAAG,4BAA4B,GAAG,IAAI;AAC/D;AACA;;AAEA,0DAAe,WAAW;;ACtB1B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,4DAAe,aAAa;;ACd5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2DAAe;;AChC2B;;AAE1C;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;;AAGA;AACA,uBAAuB,oBAAY;AACnC;;AAEA;;AAEA,WAAW;AACX;;;AAGA;AACA;AACA,mBAAmB;AACnB;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB;AACnB;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,8CAAe;;AC/DuB;;AAEtC;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,OAAa;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oDAAe,eAAe;;AC1B9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAe,YAAY;;;;;AChB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,GAAG;AACH,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA,wDAAe,aAAa;;AC7LwB;AACJ;AACI;AACE;AACJ;;AAElD;AACA;AACA;AACA,SAAS;AACT;;AAEsC;;AAEM;;AAE5C,2GAAwB,CAAC,iBAAa;;AAEtC;;AAEA,MAAM,qBAAc;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yBAAqB;AAC3B,MAAM,0GAAqB;AAC3B,MAAM,6GAAwB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,wBAAwB,qBAAc;;AAEtC;AACA;AACA,iBAAiB,6GAA0B;AAC3C,SAAS,qBAAc;AACvB;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,6GAA0B;AAC7C;AACA;AACA;AACA,cAAc,0GAAqB;AACnC;AACA,KAAK;;AAEL;AACA,8BAA8B,qBAAc;AAC5C;AACA,oBAAoB,qBAAc;AAClC;;AAEA,qBAAqB,0GAAqB;AAC1C,wBAAwB,6GAAwB;AAChD;AACA;;AAEA;AACA,sCAAsC,qBAAa;AACnD,oCAAoC,mBAAW;AAC/C,sCAAsC,qBAAa;AACnD,wCAAwC,aAAe;AACvD,qCAAqC,oBAAY;;AAEjD,6CAAe,a","sources":["webpack://flachejs/webpack/universalModuleDefinition","webpack://flachejs/external umd {\"commonjs\":\"localforage\",\"commonjs2\":\"localforage\",\"amd\":\"localforage\",\"root\":\"localforage\"}","webpack://flachejs/external umd {\"commonjs\":\"md5\",\"commonjs2\":\"md5\",\"amd\":\"md5\",\"root\":\"md5\"}","webpack://flachejs/webpack/bootstrap","webpack://flachejs/webpack/runtime/compat get default export","webpack://flachejs/webpack/runtime/define property getters","webpack://flachejs/webpack/runtime/hasOwnProperty shorthand","webpack://flachejs/webpack/runtime/make namespace object","webpack://flachejs/./src/helpers/synthResponse.js","webpack://flachejs/./src/helpers/flacheRequest.js","webpack://flachejs/./src/helpers/generateKey.js","webpack://flachejs/./src/helpers/validateCache.js","webpack://flachejs/./src/helpers/copyResponse.js","webpack://flachejs/./src/helpers/parsers.js","webpack://flachejs/./src/helpers/serverRequest.js","webpack://flachejs/./src/helpers/reqExtension.js","webpack://flachejs/./src/flacheStorage.js","webpack://flachejs/./src/flache.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"md5\"), require(\"localforage\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"md5\", \"localforage\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flachejs\"] = factory(require(\"md5\"), require(\"localforage\"));\n\telse\n\t\troot[\"flachejs\"] = factory(root[\"md5\"], root[\"localforage\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__99__, __WEBPACK_EXTERNAL_MODULE__428__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__428__;","module.exports = __WEBPACK_EXTERNAL_MODULE__99__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export class SyntheticResponse extends Response {\n  #redirected;\n  #type;\n  #url;\n  constructor(body, init) {\n    super(body, init);\n    this.#redirected = init.redirected || false;\n    this.#url = init.url || '';\n    this.#type = init.type || 'default';\n  }\n\n  get url() {\n    return this.#url;\n  }\n\n  get redirected() {\n    return this.#redirected;\n  }\n\n  get type() {\n    return this.#type;\n  }\n}\n\nexport function constructResponse(entry) {\n  const init = {\n    ...entry.response,\n    headers: new Headers(entry.response.headers),\n  }\n  /**\n   * The only properties that acan actually be set via our options are as follow: \n   * Status\n   * Status Text\n   * Headers\n   * \n   * Our 'synthetic reposne' overwirtes the getter functions for the url, redirect, and the type to mimic\n   * the native api as much as possible. Unclear if this could cause serious bugs or not yet. \n   * \n   * We should consider what if any of the other properties may interfere with the normal workflow\n   * a developer might expect, and also how this will impact any other native functions\n   * that interface with the response obj. \n   * \n   * For example - if a user is redirected, but the header is set to manual, the response will not\n   * be automatically redirected and the user will have to specify a control flow to handle this. \n   *\n   * Additionally - in testing I've noticed that the clone method does not work properly either. \n   */\n\n\n  // TO-DO Make sure to parse the data appropriately if it is text v. JSON \n  const outputResponse = new SyntheticResponse(JSON.stringify(entry.data.data), init)\n \n  return outputResponse;\n}\n\n","import { constructResponse } from './synthResponse';\n\n/**\n * Function to retreive data from Cache\n * @param {string} url - the url to the server request\n * @param {object} options - the request body\n * @return {object} Object containing the retreived data from the cache\n */\n\n const defaultOptions = {\n  method: 'GET',\n  mode: 'cors',\n  cache: 'default',\n  credentials: 'same-origin',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  redirect: 'follow',\n  referrerPolicy: 'no-referrer-when-downgrade',\n  body: null,\n}\n\n// TO-DO Add errror handling and potentially some routing. \nconst flacheRequest = async function (url, options) {\n  \n  let start = performance.now()\n\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n\n  let uniqueKey = this.generateKey(url, options);\n\n  /** Check if the cache already contains the response to the given url or exists in cache but is invalid */\n  const cacheResult = await this.store.getItem(uniqueKey)\n    .then((entry) => {\n      if (!entry) return null;\n      // needs to return data if valid and null if not;\n      return this.validateCache(uniqueKey, entry);\n    })\n    .catch(err => err);\n\n  // what should we do if this throws an err? -> err would indicate that storage is full for write operations \n  // read operations this would probably indicate an issue with the store itself. \n\n  /** If the cache does not already have stored response from the given url */\n  if (!cacheResult) {\n    /** Make a request to the server through the url param to store its response */\n    const apiResult = await this.getFetchRequest(url, options);\n\n    // if no data returned - should we try again or return an error? \n    if (!apiResult) {\n      return null;\n    }\n\n    /** Apply TTL to object to be stored in cache */\n    apiResult.ttl = Date.now() + this.ttl;\n    /** Add to cache */\n    await this.store.setItem(uniqueKey, apiResult);\n    // this is where we would potetnially trigger evictions\n    this.duration = (performance.now() - start).toFixed(2);\n    this.reqExtension(url, this.duration, 'Miss', this.ttl);\n    return constructResponse(apiResult);\n  }\n  \n  this.duration = (performance.now() - start).toFixed(2);\n  this.reqExtension(url, this.duration, 'Hit', -1);\n  return constructResponse(cacheResult);\n};\n\n\nexport default flacheRequest;\n","import md5 from 'md5';\n  \n/**\n* Function that takes in arguments of an HTTP request and returns them as a single unique (hashed) key\n* @param {string} url - request URL\n* @param {object} data - object containing request body such as the HTTP method\n* @return {string} - Hashed key\n**/\n// TO-DO consider including headers in our hashing strategy? If a POST request is made with different headers its conceivable that\n// the expected repsonse would be different;       \nconst generateKey = (url, data) => {\n  // TO-DO error handling for incorrect method\n  const method = data.method.toUpperCase();\n  if (method === 'GET') {\n    return (`${method}/${url}`);\n  }\n  if (method === 'POST') {\n    if (!Object.hasOwn(data, 'body')) throw new Error('Must include a body with POST request');\n    return (`${method}/${md5(JSON.stringify(data.body))}/${url}`);\n  }\n}\n\nexport default generateKey;","/**\n * Function that validates the cache\n * @param {string} uniqueKey - hashed key that contains request url and body\n * @param {object} data - response from the server request containing the request's TTL\n * @return {object} object cache value (keys: ttl, data) if in cache and valid, null if not\n */\nasync function validateCache(uniqueKey, data) {\n  // check if the item in the store's TTL has passed from the current time of the function call\n  if (data.ttl < Date.now()) {\n    await this.store.removeItem(uniqueKey);\n    return null;\n  } else return data;\n}\n\nexport default validateCache;","function copyResponse(res, skip = ['body']) {\n  if (!(res instanceof Response)) throw new Error('Not a valid response object'); \n\n  const newObj = {};\n  for (const key in res) {\n    // this is to avoid copying function definitions from the objects prototype; \n    // it also checks if we have marked this as a property ot skip. \n    if (skip.includes(key) || typeof res[key] === 'function') continue;\n   \n    //This is to iterate through the headers obj and copy all of the headers returned by the server\n    // we will reconstruct this later and recreate the exact same response. \n    if (key === 'headers') {\n      newObj[key] = copyHeaders(res[key]);\n      continue; \n    }\n    newObj[key] = res[key]; \n  }\n  return newObj; \n}\n\nfunction copyHeaders(header) {\n  const entries = header.entries();\n\n  const newObj = {};\n\n  for (const [key, value] of entries) {\n    newObj[key] = value;\n  }\n\n  return newObj\n}\n\nexport default copyResponse","import copyResponse from './copyResponse';\n\n/**\n * Parse response from the server to record the data type\n * Middleware pattern calls functions in order until it receives valid data from response\n * @param {Response} res - response from server request\n * @param {string} res - response from server request\n * @return {object} Object containing the resulting data from executing the request in the server and the response detils for later reconstruction. \n */\n\n\nasync function parseResponse(res) {\n  const responseCopy = copyResponse(res);\n  const dataCopy = await parseJSON(res); \n\n  if (!dataCopy) throw new Error('failed to parse data');\n\n  return { response: responseCopy, data: dataCopy };\n}\n\n\nasync function parseJSON(res) {\n  try {\n    const data = { type: 'json', data: await res.json() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseText(res);\n  }\n}\n\n\nasync function parseText(res) {\n  try {\n    const data = { type: 'text', data: await res.text() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseBlob(res);\n  }\n}\n\n// Note these are still in experimental phase\nasync function parseBlob(res) {\n  try {\n    const data = { type: 'blob', data: await res.blob() }\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return parseArrayBuffer(res);\n  }\n}\n\nasync function parseArrayBuffer(res) {\n  try {\n    const data = { type: 'buffer', data: await res.arrayBuffer() };\n    return data\n  } catch (err) {\n    console.log(err.message);\n    return null;\n  }\n}\n\nexport default parseResponse","import parseResponse from './parsers'; \n\n/**\n * Function that makes a Fetch request to the server\n * @param {string} url URL to where fetch request is being made\n * @return {object} Object containing the resulting data from executing the request in the server\n */\n\n/**\n * How will we handle being redirected? \n */\n\nasync function getFetchRequest(url, options) {\n  // TO-DO handling headers, response-types, etc for how to parse data; \n  let response = await fetch(url, options)\n    .then(res => {\n      const proxyResponse = parseResponse(res);\n      return proxyResponse;\n    })\n    .catch(err => {\n      console.log('Fetch error', err.message);\n      return err;\n    });\n  return response;\n}\n\nexport default getFetchRequest;","const reqExtension = (url, duration, inCache, TTL) => {\n    // Send data to our Extension\n    if(chrome && chrome.runtime && chrome.runtime.sendMessage) {\n        async function sendReq () {\n          let aRequest = {\n            requestURL: url,\n            time: duration, \n            inCache: inCache,\n            ttl: TTL\n          }\n          chrome.runtime.sendMessage(\"bmkhjogdgeafjdanmhjddmcldejpgaga\", aRequest);\n        }  \n        sendReq();\n    }\n}\n  \nexport default reqExtension;","class Node {\n  constructor(key, val) {\n    this.key = key;\n    this.value = val;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\n// Implement the driver here.\nconst flacheStorage = {\n  _driver: 'FLACHESTORAGE',\n  _initStorage: function(capacity, options) {\n    this.capacity = capacity;\n    this.cache = new Map(); \n    this.head = null;\n    this.tail = null;\n\n    if (options) {\n      for (let key in options) {\n        this.cache[key] = options[key];\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  clear: function (callback) {\n\n    return new Promise((resolve, reject) => { \n      try {\n        this.cache.clear(); \n        resolve(true);\n      } catch (err) {\n        reject(err)\n      }\n    })\n  },\n  \n  getItem: function(key) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.cache.has(key)) {\n          let node = this.cache.get(key);\n          this.moveToFront(node);\n          return resolve(node.value);\n        }\n        \n        return resolve(null);\n      } catch (err) {\n        reject(err); \n      }\n    })\n  },\n\n  iterate: function(iteratorCallback, successCallback) {\n      // Custom implementation here...\n      // TO-DO \n  },  \n\n  key: function (n, callback) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (n < 0 || !this.head) return resolve(null);\n    \n        if (n === 0) {\n          if (!callback) resolve(this.head.key);\n          resolve(callback(this.head.key));\n        } \n        \n        let start = this.head; \n        let count = 0;\n    \n        while (start) {\n          start = start.next;\n          count++;\n          if (count === n) break;\n        }\n    \n        if (count < n) resolve(null);\n    \n        if(!callback) resolve(start.key);\n        resolve(callback(start.key));\n      } catch (err) {\n        reject(err);\n      }\n  })\n  },\n\n  keys: function (callback) {\n    return new Promise((resolve, reject) => {\n      try {\n        const keys = this.cache.keys();\n        if (!callback) resolve([...keys])\n        resolve(callback([...keys]));\n      } catch (err) {\n        reject(err)\n      }\n    })\n  },\n\n  length: function (callback) {\n    return this.keys().then(keys => {\n      const length = keys.length;\n      if (!callback) return length;\n      return callback(length);\n    });\n  },\n\n  removeItem: function(key, callback) {\n    delete this.cache[key];\n    return Promise.resolve();\n  },\n\n  setItem: function(key, value) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.cache.has(key)) {\n          let node = this.cache.get(key);\n          node.value = value;\n          this.moveToFront(node);\n          resolve(value);\n        }\n        \n        let node = new Node(key, value);\n    \n        if (this.cache.size === this.capacity) {\n          this.cache.delete(this.tail.key);\n          this.deleteNode(this.tail);\n        }\n    \n        this.cache.set(key, node);\n        this.addFirst(node);\n        resolve(value);\n\n      } catch (err) {\n        reject(err);\n      }\n    })\n  },\n\n  moveToFront: function(node) {\n    this.deleteNode(node);\n    this.addFirst(node);\n    return;\n  },\n\n  deleteNode: function(node) {\n    let prevNode = node.prev;\n    let nextNode = node.next;\n\n    if (prevNode) {\n      prevNode.next = nextNode;\n    } else {\n      this.head = nextNode;\n    }\n\n    if (nextNode) {\n      nextNode.prev = prevNode;\n    } else {\n      this.tail = prevNode;\n    }\n\n    return;\n  },\n\n  addFirst: function(node) {\n    node.next = this.head;\n    node.prev = null;\n\n    if (this.head) {\n      this.head.prev = node;\n    }\n\n    this.head = node;\n\n    if (!this.tail) {\n      this.tail = node;\n    }\n\n    return;\n  },\n \n  printLL: function () {\n    console.log('This is our Linked List \\n', this.head)\n  }\n}\n\n\nexport default flacheStorage;","import flacheRequest from './helpers/flacheRequest';\nimport generateKey from './helpers/generateKey';\nimport validateCache from './helpers/validateCache';\nimport getFetchRequest from './helpers/serverRequest';\nimport reqExtension from './helpers/reqExtension';\n\n/**\n * The localforage module\n * @external \"localforage\"\n * @see {@link https://www.npmjs.com/package/localforage}\n */\n\nimport localforage from 'localforage';\n\nimport FLACHESTORAGE from './flacheStorage';\n\nlocalforage.defineDriver(FLACHESTORAGE);\n\n// import testStorage from './flacheStorageTest';\n\nconst defaultOptions = {\n  maxCapacity: null, // this is only relevant for local memory at the moment. \n  ttl: 5000,\n  duration: null,\n  config: {\n    name: 'httpCache',\n    storeName: 'request_response',\n    description: 'A cache for client-side http requests',\n    driver: [\n      FLACHESTORAGE._driver,\n      localforage.INDEXEDDB,\n      localforage.LOCALSTORAGE,\n    ],\n    version: 1.0, // this is only relevant if using IndexedDB\n  }\n}\n\n/** class clientCache provides a container for our db store */\nclass clientCache {\n\n  /**\n   * create a clientCache\n   * @param {object} options - further options for configuring the store\n   */\n  \n  constructor(options = defaultOptions) {\n\n    /** Create store and override the default store options with user-given configurations */\n    // TO-DO: check if the store exists already and create new store only if it isn't already there.\n    this.store = localforage.createInstance(({\n      ...defaultOptions.config,\n      ...options.config\n    }))\n\n    /** Create details store */\n    // TO-DO: same as above. \n    this.details = localforage.createInstance({\n      name: 'cacheDetails',\n      storeName: 'requests',\n      description: 'A list of past requests',\n      driver: localforage.INDEXEDDB,\n      version: 1.0,\n    })\n\n    /** Apply TTL (time to live) and maxCapacity from user configuration or default */\n    this.ttl = options.ttl || defaultOptions.ttl;\n    this.maxCapacity = options.maxCapacity;\n    this.duration = defaultOptions.duration;\n  }\n\n  static INDEXEDDB = localforage.INDEXEDDB;\n  static LOCALSTORAGE = localforage.LOCALSTORAGE;\n  static MEMORY = 'FLACHESTORAGE';\n}\n\n/** bind helper functions to class clientCache */\nclientCache.prototype.flacheRequest = flacheRequest;\nclientCache.prototype.generateKey = generateKey;\nclientCache.prototype.validateCache = validateCache;\nclientCache.prototype.getFetchRequest = getFetchRequest;\nclientCache.prototype.reqExtension = reqExtension;\n\nexport default clientCache"],"names":[],"sourceRoot":""}